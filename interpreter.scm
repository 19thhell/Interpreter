(define (repl)
  (display ">>>")
  (let ((exp (read)))
	(cond ((equal? exp '(exit)) 'done)
		  (else (display (top-eval exp))
				(newline)
				(repl))
		  )))

(define (my-load filename)
  (load-repl (open-input-file filename)))

(define (load-repl port)
  (let ((exp (read port)))
	(cond ((eof-object? exp) 'done)
		  (else (let ((res (top-eval exp)))
				  (display res)
				  (newline)
				  (load-repl port)))
		  )))

(define (my-apply fn args)
  (cond ((eq? (car fn) 'primitive-function) (apply (cadr fn) args))
		(else (let ((formals (cadr (cadr fn)))
					(body (cddr (cadr fn)))
					(env (caddr fn)))
				(if (arg-test formals args)
				  (handle-block body (append (bind formals args) env))
				  (display "Error: Arguments not match"))))
		))

(define (top-eval exp)
  (cond ((not (pair? exp)) (my-eval exp *global-env*))
		((eq? (car exp) 'define)
		 (handle-define exp *global-env*))
		(else (my-eval exp *global-env*))
		))

(define (my-eval exp env)
  (cond
	((symbol? exp) (lookup exp env))
	((not (pair? exp)) exp)
	((eq? (car exp) 'repl) (repl))
	((eq? (car exp) 'quote) (cadr exp))
	((eq? (car exp) 'if)
	 (handle-if (cadr exp) (caddr exp) (cadddr exp) env))
	((eq? (car exp) 'cond)
	 (handle-cond (cdr exp) env))
	((eq? (car exp) 'lambda)
	 (list 'closure exp env))
	((eq? (car exp) 'let)
	 (handle-let (cadr exp) (cddr exp) env))
	((eq? (car exp) 'let*)
	 (handle-let* (cadr exp) (cddr exp) env))
	((eq? (car exp) 'letrec)
	 (handle-letrec (cadr exp) (cddr exp) env))
	((eq? (car exp) 'define)
	 (handle-define exp env))
	((eq? (car exp) 'and)
	 (handle-and (cdr exp) env))
	((eq? (car exp) 'or)
	 (handle-or (cdr exp) env))
	(else
	  (handle-call (map (lambda (sub-exp) (my-eval sub-exp env)) exp)))
	))

(define (insert! val L)
  (set-cdr! L (cons (car L) (cdr L)))
  (set-car! L val))

(define (lookup var env)
  (let ((item (assoc var env)))
	(cond ((not item) (display "Error: Undefined symbol ")
					  (display var)
					  (newline))
		  (else (cadr item))
		  )))

(define (handle-if test then-exp else-exp env)
  (if (my-eval test env)
	(my-eval then-exp env)
	(my-eval else-exp env)))

(define (handle-cond cond-clause env)
  (if (eq? cond-clause '())
	'(cond)
	(if (eq? (caar cond-clause) 'else)
	  (handle-block (cdar cond-clause) env)
	  (if (my-eval (caar cond-clause) env)
		(handle-block (cdar cond-clause) env)
		(handle-cond (cdr cond-clause) env)
		))))

(define (handle-let defs body env)
  (handle-block body (append (let-env defs env) env)))

(define (let-env defs env)
  (cond ((null? defs) '())
		(else (cons (list (caar defs) (my-eval (cadar defs) env))
					(let-env (cdr defs) env)))
		))

(define (handle-let* defs body env)
  (handle-block body (let*-env defs env)))

(define (let*-env defs env)
  (cond ((null? defs) env)
		(else (let ((res (list (caar defs) (my-eval (cadar defs) env))))
				(let*-env (cdr defs) (cons res env)))
			  )))

(define (handle-letrec defs body env)
  (handle-block body (recursive defs (append (letrec-env defs env) env))))

(define (letrec-env defs env)
  (cond ((null? defs) '())
		(else (cons (list (caar defs) 'uninitialized)
					(letrec-env (cdr defs) env)))
		))

(define (recursive defs env)
  (cond ((null? defs) env)
		(else (set-car! (cdr (assoc (caar defs) env)) (my-eval (cadar defs) env))
			  (recursive (cdr defs) env)
			  env)
		))

(define (handle-call evald-exps)
  (let ((fn (car evald-exps))
		(args (cdr evald-exps)))
	(cond
	  ((eq? (car fn) 'closure)
	   (let ((formals (cadr (cadr fn)))
			 (body (cddr (cadr fn)))
			 (env (caddr fn)))
		 (if (arg-test formals args)
		   (handle-block body (append (bind formals args) env))
		   (display "Error: Arguments not match"))))
	  ((eq? (car fn) 'primitive-function)
	   (apply (cadr fn) args))
	  (else (display "Error: Calling non-function"))
	  )))

(define (arg-test formals actuals)
  (cond ((null? formals) (if (null? actuals) #t #f))
		((null? actuals) #f)
		(else (arg-test (cdr formals) (cdr actuals)))
		))

(define (bind formals actuals)
  (cond ((null? formals) '())
		(else (cons (list (car formals) (car actuals))
					(bind (cdr formals) (cdr actuals))))
		))

(define (handle-block block env)
  (cond ((null? block) (display "Error: Can not have empty block or body"))
		((null? (cdr block)) (my-eval (car block) env))
		(else (my-eval (car block) env)
			  (handle-block (cdr block) env))
		))

(define (handle-define exp env)
  (cond ((not (pair? (cadr exp)))
		 (insert! (list (cadr exp) (my-eval (caddr exp) env)) env)
		 (cadr exp))
		(else (insert! (list (caadr exp) (list 'closure (append (list 'lambda (cdadr exp)) (cddr exp)) env)) env)
			  (caadr exp))
		))

(define (handle-and terms env)
  (cond ((null? terms) #t)
		(else (let ((val (my-eval (car terms) env)))
				(if val (handle-and (cdr terms) env) #f)))
		))

(define (handle-or terms env)
  (cond ((null? terms) #f)
		(else (let ((val (my-eval (car terms) env)))
				(if val #t (handle-and (cdr terms) env))))
		))

(define *global-env*
  (list 
	(list 'car (list 'primitive-function car))
	(list 'cdr (list 'primitive-function cdr))
	(list 'set-car! (list 'primitive-function set-car!))
	(list 'set-cdr! (list 'primitive-function set-cdr!))
	(list 'cons (list 'primitive-function cons))
	(list 'list (list 'primitive-function list))
	(list '+ (list 'primitive-function +))
	(list '- (list 'primitive-function -))
	(list '* (list 'primitive-function *))
	(list '= (list 'primitive-function =))
	(list '< (list 'primitive-function <))
	(list '> (list 'primitive-function >))
	(list '<= (list 'primitive-function  <=))
	(list '>= (list 'primitive-function >=))
	(list 'eq? (list 'primitive-function eq?))
	(list 'pair? (list 'primitive-function pair?))
	(list 'symbol? (list 'primitive-function symbol?))
	(list 'null? (list 'primitive-function null?))
	(list 'read (list 'primitive-function read))
	(list 'display (list 'primitive-function  display))
	(list 'open-input-file (list 'primitive-function open-input-file))
	(list 'close-input-port (list 'primitive-function close-input-port))
	(list 'eof-object? (list 'primitive-function eof-object?))
	(list 'load (list 'primitive-function my-load))
	(list 'apply (list 'primitive-function my-apply))
	))
